"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const logging_1 = require("logging");
const logger = logging_1.default('broker');
const amqp = require("amqplib");
const uuidv4 = require("uuid/v4");
class Broker {
    constructor(config) {
        this._noAck = false;
        this._conn = null;
        this.ch = NaN;
        this.consumes = new Map();
        this.config = config;
    }
    get noAck() {
        return this._noAck;
    }
    set noAck(_noAck) {
        this._noAck = _noAck;
    }
    get conn() {
        return this._conn;
    }
    get channel() {
        return this.ch;
    }
    close() {
        this.ch.close();
    }
    connect() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._conn !== null) {
                logger.info("[connect] looks like broker is already connected, skip");
                return;
            }
            if (!this.config.connection.host) {
                throw "rabbitMQ host name is undefined! unable to connect";
            }
            if (!this.config.connection.port) {
                this.config.connection.port = 5672;
            }
            let url = `amqp://${this.config.connection.host}:${this.config.connection.port}`;
            try {
                logger.info(`[connect] going to connect to ${this.config.connection.host}:${this.config.connection.port}`);
                this._conn = yield amqp.connect(url);
                this.ch = yield this._conn.createChannel();
                this._conn.on("error", (err) => {
                    this._conn = null;
                    if (err.message !== "connection closing") {
                        logger.error("[Broker-AMQP] conn error", err.message);
                    }
                });
                this._conn.on("close", () => {
                    this._conn = null;
                    logger.error("[Brokeurlr-AMQP] reconnecting ..");
                    setTimeout(this.connect, 1000);
                });
                logger.info(`[connect] connected to ${this.config.connection.host}:${this.config.connection.port} is ok!`);
            }
            catch (e) {
                logger.info('ERROR! [connect] on trying to connection to ' + url);
                this._conn = null;
                setTimeout(this.connect, 1000);
            }
        });
    }
    addConsume(queue, cb, init = true) {
        return __awaiter(this, void 0, void 0, function* () {
            this.consumes.set(queue, cb);
            if (init) {
                yield this.init();
                return;
            }
            yield this.ch.consume(queue, cb, { noAck: !this.noAck });
        });
    }
    initQueueCB(q_created) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info("initQueueCB: q = " + JSON.stringify(q_created));
            let needed_binding = this.config.binding.filter((b) => {
                if (b.target === q_created.queue)
                    return b;
            });
            for (let b of needed_binding) {
                logger.info("initQueueCB: binding - " + JSON.stringify(b));
                yield this.ch.bindQueue(b.target, b.exchange, b.keys);
                this.ch.consume(b.target, this.consumes.get(b.target), { noAck: !this.noAck });
                logger.info(`initQueueCB: consume - ${b.target} is ok`);
            }
        });
    }
    createQueue(q) {
        return __awaiter(this, void 0, void 0, function* () {
            logger.info("createQueue q = " + JSON.stringify(q));
            let theQ = yield this.ch.assertQueue(q.name, q.options);
            yield this.initQueueCB.bind(this)(theQ);
        });
    }
    init() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.connect();
            try {
                yield Promise.all(this.config.exchanges.map((ex) => {
                    this.ch.assertExchange(ex.name, ex.type, ex.options);
                }));
                logger.info("init exchanges ok");
            }
            catch (e) {
                logger.info(e);
            }
            for (let v of this.config.queues) {
                yield this.createQueue.bind(this)(v);
            }
        });
    }
    addExchange(name, type, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ch.assertExchange(name, type, options);
            //this.config.exchanges.push({name, type, options});
        });
    }
    addQueue(name, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield yield this.ch.assertQueue(name, options);
            //this.config.queues.push({name, options});
        });
    }
    addBinding(exchange, target, keys) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.ch.bindQueue(target, exchange, keys);
            //this.config.binding.push({exchange: exchange, target: target, keys: keys});
        });
    }
    send(ex, key, msg, options = null, noAck = true) {
        let _options = {
            persistent: false,
            noAck: noAck,
            timestamp: Date.now(),
            contentEncoding: "utf-8",
            contentType: "application/json",
            headers: {
                messageId: uuidv4(),
                source: ex + ":" + key
            }
        };
        options = options === null ? _options : options;
        let msgToSend = msg;
        if (typeof msg === 'object') {
            msgToSend = JSON.stringify(msg);
        }
        this.ch.publish(ex, key, Buffer.from(msgToSend), options);
    }
}
exports.Broker = Broker;
exports.default = Broker;
